//let v1;
//let v2;
let result;
let x, y, radius;
let plankton = [] // list/array
const PLANKTON_R = 10
let initialNumberOfPlankton = 4
let position;
let velocity;
let acceleration;
let fish;
//const SPEED = 3
//const plankton_SIZE_MIN = 3
//const plankton_SIZE_MAX = 5

function setup() {
  createCanvas(400, 400);
  fish = new Fish(width/2,height/2)
  position = createVector(width / 2, height / 2); // Start at the center
  velocity = createVector(0, 0); 
  acceleration = createVector(1, 0); 
  //v2 = createVector(5,10);
 //result = p5.Vector.add(v1, v2);
  
  //call plankton fish interaction function
  //drawplankton (50,50,40)
 // radius = 5;
 x = width/2;
  y = height/2;
  //slow down plankton by making the range smaller
 // dx = random(-2,1);
 //dy= random (-2, 1);
  ellipseMode(RADIUS)
 resetAllplankton()  
  // noLoop()
  
}

function draw() {
  background(0,0,139);

  //drawplankton();
  //fish
  fish.position = createVector(mouseX,mouseY)
  fish.draw()  
  //plankton array
   //velocity.add(acceleration);
  //position.add(velocity);
  //fill("green");  
  for( let i = plankton.length - 1; i >= 0; i-- ) { // for each loop (loop over every item
    let p = plankton [i]; {
    drawplankton(p);
    if( checkCollisions(fish,p)) {
      fish.atePlankton();
      plankton.splice (i, 1);
    }
 }
}
} 


function drawplankton(plankton) {
  fill("green")
  let tdelta = 2;
  let acc = 0.1;
  //using velocity and acceleration for plankton
  ellipse(plankton.position.x, plankton.position.y, PLANKTON_R)
  plankton.position.y += (tdelta*plankton.velocity.y + tdelta*tdelta*acc*plankton.direction.y/2)*plankton.direction.y;
  plankton.velocity.y += tdelta*acc*plankton.direction.y;

  plankton.position.x += (tdelta*plankton.velocity.x )*plankton.direction.x;
  

  if(plankton.position.y>=400 || plankton.position.y<=0){
    plankton.direction.y *= -1
    // plankton.velocity.y = 0
  }
  if (plankton.position.x>=400|| plankton.position.x <= 0){
    plankton.direction.x *= -1
  }

}


//function keepInBounds (p) {
//  if (p.position.x + p.radius > width) {
  //  p.velocity.x *= -1
  //}

  //if (p.position.y + p.radius > height) {
   // p.velocity.y *= -1
 // }

 // if (p.position.x - p.radius < 0) {
  //  p.velocity.x *= -1
 // }

  //if (p.position.y - p.radius < 0) {
   // p.velocity.y *= -1
  //}
//}



// Create a plankton
function createplankton () {
  return {
    position: createVector(random(width), random(height)),
    velocity: p5.Vector.random2D(),
    direction: {
      x: 1,
      y: 1
    }
  }
}

function resetAllplankton () {
  //plankton = [] // create an empty array
 while (plankton.length < initialNumberOfPlankton) {
 plankton.push(createplankton())
 }
}

class Fish {
  constructor (x, y, w = 400, h = 400) {
    this.position = createVector(x, y)
    this.velocity = p5.Vector.random2D()
    this.w = w
    this.h = h
    this.r = 65
    const ROTATE_DEGREES = 30
    const frontRotationOffset =
      sin(map(frameCount % 31, 0, 30, 0, TWO_PI)) * ROTATE_DEGREES
    this.fishColor = color("#ADD8E6");
    this.colorTimer = 0;
  }
  
  atePlankton() {
    this.fishColor = color("#FF0000")
    this.colorTimer = 45;
  }

  //create fish body
  // have an idea of what we are drawing
  //break that down into our basic shapes
  //position the shapes function
  //remeber the drawing canvas
  draw () {
    noStroke()
    push()
    translate(this.position.x, this.position.y)
    // rotate(this.rotation+PI/2)
    fill(this.fishColor)
    ellipse(0, 0, 65, 40)

    // Size and location for triangle fin

    let centerX = 0
    let centerY = -40
    let size = 35
    fill(this.fishColor)
    // noStroke();

    // Define the three vertices for fin
    // Point 1 (Top point)
    // Point 2 (Bottom Left point)
    // Point 3 (Bottom Right point)
    // Draw the triangle
    triangle(
      centerX,
      centerY - size,
      centerX - size,
      centerY + size,
      centerX + size,
      centerY + size
    )

    //fish spots
    fill('black')
    circle(0, 0, 2)
    circle(10, 0, 2)
    circle(0, -10, 2)
    circle(10, -10, 2)
    circle(0, 10, 2)

    //fish eye
    fill('black')
    ellipse(35, -15, 5, 5)
    // // body ellipse;
    fill(this.fishColor)

    push()
    translate(10, -60)
    rotate(radians(sin(map(frameCount % 60, 0, 59, 0, TWO_PI)) * 9))
    triangle(0, 20, -160, 200, -190, 140)
    // side fin
    fill(this.fishColor)
    rect(-110, 30, 90, 10)
    pop()

    stroke('black')
    fill('white')
    rect(37, 0, 20, 20)
    pop()
    // circle(this.position.x, this.position.y,this.w)
    this.colorTimer--
   // lerp, color, map(colorTimer, 0, 45,  0, 1) color("#ADD8E6"), color("#FF00000"))
    if( this.colorTimer <= 0 ) {
      this.fishColor = color("#ADD8E6");
    }
  }
}
function checkCollisions(fish, plankton) {
  // console.log( fish, plankton )
  let d = dist (fish.position.x, fish.position.y, plankton.position.x, plankton.position.y);
  return d < fish.r + PLANKTON_R
}
